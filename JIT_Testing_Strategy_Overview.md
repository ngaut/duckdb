# LuaJIT JIT PoC - Testing Strategy Overview

This document outlines the testing strategy employed for the LuaJIT Just-In-Time (JIT) compilation Proof-of-Concept (PoC) within DuckDB, primarily focusing on the unit tests in `test/unittest/jit_expression_executor_test.cpp`.

## 1. Core Test File: `jit_expression_executor_test.cpp`

This file contains the most comprehensive set of unit tests for the JIT functionality. It aims to verify:
- Functional correctness of JITed expressions across various types and operations.
- Correct behavior of JIT mechanics such as caching, heuristics, and error fallback.
- Correctness of the JIT configuration options.
- The structural correctness of the generated Lua code.

## 2. Primary Testing Approach: `ExpressionExecutor::ExecuteExpression`

The majority of functional tests are designed to use the public API of `ExpressionExecutor`, specifically `AddExpression()` followed by `ExecuteExpression()`. This approach treats the JIT compilation and execution pipeline largely as a black box from the test's perspective when verifying correctness.

**Typical Test Flow:**
1.  **Setup:**
    *   A `DuckDB` instance and `ClientContext` are created.
    *   JIT is enabled in `ClientContext::config.options` (e.g., `enable_luajit_jit = true`), and thresholds (`luajit_jit_complexity_threshold`, `luajit_jit_trigger_count`) are often set to 0 to ensure JIT is attempted on the first execution for testing purposes.
    *   Input data is prepared in a `DataChunk` with appropriate `duckdb::Vector` types.
    *   A `BoundExpression` tree representing the SQL expression to be tested is constructed using helper functions (e.g., `CreateBoundConstant`, `CreateBoundBinaryOperator`, `CreateBoundFunction`).
    *   An `ExpressionExecutor` is instantiated with the context.
    *   The `BoundExpression` is added to the executor.
    *   The input `DataChunk` is set for the executor.
    *   An output `duckdb::Vector` is prepared.
2.  **Execution:**
    *   `executor.ExecuteExpression(expr_idx, output_vector)` is called. This triggers the internal JIT logic within `ExpressionExecutor::Execute()`:
        *   Identification of unique input columns and creation of the input mapping for Lua arguments.
        *   Instantiation of `LuaTranslatorContext`.
        *   Call to `LuaTranslator::TranslateExpressionToLuaRowLogic` to get the Lua row logic snippet.
        *   Call to `ExpressionExecutor::ConstructFullLuaFunctionScript` to generate the complete block-processing Lua function (which includes the main `for i=0, count-1 do ... end` loop, FFI casts, the row logic snippet, and output handling).
        *   Compilation of the Lua script via `LuaJITStateWrapper`.
        *   Preparation of `FFIVector`s for input/output using `CreateFFIVectorFromDuckDBVector`.
        *   Execution of the JITed Lua function via `LuaJITStateWrapper::PCallGlobal`.
3.  **Verification:**
    *   The content of the `output_vector` is compared against expected values.
    *   `ExpressionState` flags (e.g., `attempted_jit_compilation`, `jit_compilation_succeeded`) are checked to confirm the JIT path was taken and whether it was successful.
    *   Null propagation is verified by checking `FlatVector::IsNull` on the output vector.

This end-to-end approach ensures that all components of the block-processing JIT pipeline work together correctly for a wide range of expression types (numeric, string, temporal, conditional, logical) and data variations (NULLs, different vector types if applicable, though tests primarily use FLAT).

## 3. Verification of JIT Mechanics

Specific test cases are dedicated to JIT mechanics:

*   **Caching (`JIT ExpressionExecutor Caching Logic`):** Verifies that an expression is compiled only once by checking `ExpressionState::jitted_lua_function_name` and ensuring no re-compilation attempts on subsequent executions.
*   **Error Handling and Fallback (`JIT ExpressionExecutor Error Handling and Fallback`):** Intentionally triggers Lua runtime errors. Verifies that `duckdb::RuntimeException` is thrown, `ExpressionState::jit_compilation_succeeded` is set to `false`, and subsequent executions correctly use the C++ fallback path (`ExecuteStandard`).
*   **JIT Configuration Options (`JIT Configuration Options Functionality`):** Modifies `ClientContext::config.options` (e.g., `enable_luajit_jit`, `luajit_jit_complexity_threshold`, `luajit_jit_trigger_count`) and then calls `ExecuteExpression`. It checks `ExpressionState` flags to confirm that the `ShouldJIT` logic within `ExpressionExecutor` correctly respects these settings.

## 4. Verification of Generated Lua Code Structure

*   **`TestConstructFullLuaFunctionScriptOutput_NonVARCHAR`**
*   **`TestConstructFullLuaFunctionScriptOutput_VARCHAR`**

These tests are designed to verify the structural correctness of the Lua code generated by the static private method `ExpressionExecutor::ConstructFullLuaFunctionScript`.
*   They define sample Lua row logic snippets (as would be produced by `LuaTranslator`).
*   They set up a `LuaTranslatorContext` and output `LogicalType`.
*   They contain a manually crafted "golden" string representing the expected full Lua script for both non-VARCHAR and VARCHAR output scenarios under the block-processing model. This includes FFI cdefs, the Lua function signature with `input0_ffi`, etc., initial FFI casts, the main loop, embedding of the row logic, and the final output handling (direct assignment for non-VARCHAR, `results_table` and batch FFI call for VARCHAR).
*   Currently, these tests use `SUCCEED("Conceptual test...")` as `ConstructFullLuaFunctionScript` is private. For actual execution, this method would need to be made accessible for testing (e.g., via a test hook or by making the test class a friend). The "golden" strings serve as precise documentation of the expected code generation.

## 5. Other Test Files

*   **`test/unittest/luajit_translator_test.cpp`:** Contains unit tests specifically for `LuaTranslator::TranslateExpressionToLuaRowLogic`. These tests focus on ensuring the Lua *snippet* for row logic is correctly generated (i.e., setting `current_row_val` and `current_row_is_null`, and for VARCHAR outputs, adding to `results_table`).
*   **`test/unittest/luajit_ffi_test.cpp`:** Contains tests for basic FFI data struct marshalling and C FFI helper functions, ensuring the low-level data exchange and helper calls work as expected.

This multi-layered testing strategy aims to provide confidence in the correctness of the JIT compilation feature from low-level FFI interactions to high-level expression evaluation through the `ExpressionExecutor`.
