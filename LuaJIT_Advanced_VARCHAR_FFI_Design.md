# LuaJIT Advanced VARCHAR FFI Design (Block-Processing)

## 1. Objective

The primary goal of this design is to further minimize FFI (Foreign Function Interface) overhead for expressions involving `VARCHAR` data types within the block-processing model. Specifically, this design focuses on:
1.  Optimizing `VARCHAR` inputs where possible (e.g., for `LENGTH`).
2.  Significantly reducing FFI calls for `VARCHAR` outputs by batching string results from Lua and committing them to the DuckDB output `Vector` in a single FFI call per data chunk.

This builds upon the existing block-processing architecture where the main loop over rows is already inside the JITed Lua function.

## 2. Recap of `FFIVector` and `FFIString`

The existing `duckdb::ffi::FFIVector` and `duckdb::ffi::FFIString` structs remain the foundation for data exchange:

```c++
// From luajit_ffi_structs.hpp
struct FFIVector {
    void* data;
    bool* nullmask;
    idx_t count;
    LogicalTypeId ffi_logical_type_id;
    VectorType ffi_duckdb_vector_type;
    duckdb::Vector* original_duckdb_vector;
};

struct FFIString {
    char* ptr;
    uint32_t len;
};
```
Input `VARCHAR` vectors are presented to Lua as an array of `FFIString` structs (`FFIString*`).

## 3. Input String Optimization (Minor Refinement)

*   **`LENGTH(varchar_col)`:**
    *   The `LuaTranslator` can generate more optimal Lua code for the `LENGTH` function (or `octet_length`). Instead of creating a full Lua string via `ffi.string(inputX_data[i].ptr, inputX_data[i].len)` just to get its length with `#`, it can directly use the `.len` field from the `FFIString` struct.
    *   Example Lua snippet generated by `LuaTranslator` for `LENGTH(col_str)` where `col_str` is `inputK_data[i]`:
      ```lua
      -- (within the per-row logic, after inputK_data[i] and inputK_is_null are known)
      if inputK_is_null then
          current_row_is_null = true
      else
          current_row_is_null = false
          current_row_value = inputK_data[i].len -- Direct access to length
      end
      ```
*   **Other String Operations:**
    *   For most other string operations that require manipulation of the string content in Lua (e.g., `LOWER`, `SUBSTRING` if done in Lua, `REPLACE` if done in Lua), the creation of a Lua string object via `ffi.string(inputX_data[i].ptr, inputX_data[i].len)` per row is likely still necessary. This has an associated cost (memory allocation for Lua string, potential data copy).

## 4. Output String Strategy: Batching via Lua Table

To reduce the FFI overhead of calling `duckdb_ffi_add_string_to_output_vector` for each row, this strategy proposes accumulating all string results (or `nil` for SQL NULLs) for a chunk into a Lua table. After the loop completes, a single new FFI C helper function is called to transfer all strings from this Lua table to the DuckDB output `Vector`.

### 4.1. Generated Lua Function Structure (VARCHAR Output)

The `ExpressionExecutor::ConstructFullLuaFunctionScript` will generate Lua functions for `VARCHAR`-returning expressions like this:

```lua
-- Global ffi.cdef for FFIVector, FFIString, FFIInterval, and C helpers
-- This should now include the new duckdb_ffi_add_lua_string_table_to_output_vector
-- ffi.cdef[[
--   ... (existing cdefs) ...
--   int duckdb_ffi_add_lua_string_table_to_output_vector(lua_State* L); -- Or alternative signature
-- ]]

function JIT_DUCKDB_VARCHAR_EXPR_XYZ(output_vec_ffi, input0_ffi, ..., count)
    -- 1. Initial FFI Casts for inputs (as before)
    -- Example for one input:
    -- local input0_data = ffi.cast("FFIString*", input0_ffi.data)
    -- local input0_nullmask = ffi.cast("bool*", input0_ffi.nullmask)
    -- ... (casts for all other inputs)

    -- Output nullmask is still directly accessible for setting true on NULL
    local output_nullmask = ffi.cast("bool*", output_vec_ffi.nullmask)

    -- 2. Initialize Lua table for results (1-indexed for Lua convention)
    local results_table = {} -- Create a new table for this chunk

    -- 3. Main Processing Loop
    for i = 0, count - 1 do -- Iterates 0 to count-1 to match C-style indexing for FFIVectors
        local current_row_value -- This will be a Lua string or nil
        local current_row_is_null = false

        ---------------------------------------------------------------------------
        -- Begin Row Logic (from LuaTranslator::TranslateExpressionToLuaRowLogic)
        -- This snippet computes 'current_row_value' and 'current_row_is_null'.
        -- Example for LOWER(input0_data[i]):
        if input0_nullmask[i] then
            current_row_is_null = true
        else
            current_row_is_null = false
            local temp_str = ffi.string(input0_data[i].ptr, input0_data[i].len)
            current_row_value = string.lower(temp_str)
        end
        -- End Row Logic (from LuaTranslator)
        ---------------------------------------------------------------------------

        -- Store result in the Lua table (use i+1 for 1-based Lua table indexing)
        if current_row_is_null then
            results_table[i+1] = nil -- Store Lua nil for SQL NULL
        else
            results_table[i+1] = current_row_value
        end
    end -- End of main processing loop

    -- 4. Batch FFI Call for String Output (after the loop)
    -- The C function will receive output_vec_ffi (as lightuserdata), results_table (as table),
    -- and count (as number) via the Lua stack.
    duckdb_ffi_add_lua_string_table_to_output_vector(output_vec_ffi, results_table, count)
end
```

### 4.2. New C FFI Helper Function for Batch String Output

A new C function needs to be implemented and registered with Lua.

*   **Proposed C Signature (callable from Lua):**
    ```c++
    // extern "C" int duckdb_ffi_add_lua_string_table_to_output_vector(lua_State* L);
    // This signature is standard for functions registered with `lua_register` or `lua_pushcfunction`.
    // Lua would call it as: duckdb_ffi_add_lua_string_table_to_output_vector(output_vec_ffi_ptr, results_table, count_val)
    // The C function would then use lua_touserdata, lua_istable, lua_tointeger to get args from stack.
    ```
    Let's refine the call from Lua and how C retrieves args for clarity:
    Lua call: `return_code = common_ffi.duckdb_ffi_add_lua_string_table_to_output_vector(output_vec_ffi, results_table, count)`
    C function registered to `common_ffi.duckdb_ffi_add_lua_string_table_to_output_vector`.

    **C Implementation `duckdb_ffi_add_lua_string_table_to_output_vector(lua_State* L)`:**
    ```c++
    // extern "C" int duckdb_ffi_add_lua_string_table_to_output_vector(lua_State* L) {
    //     // 1. Get arguments from Lua stack
    //     // Arg 1: output_vec_ffi (lightuserdata pointing to FFIVector)
    //     duckdb::ffi::FFIVector* ffi_out_vec = (duckdb::ffi::FFIVector*)lua_touserdata(L, 1);
    //     // Arg 2: results_table (Lua table)
    //     luaL_checktype(L, 2, LUA_TTABLE); // Ensure it's a table
    //     // Arg 3: count (integer)
    //     int count = luaL_checkinteger(L, 3); // Or idx_t if using appropriate conversion
    //
    //     if (!ffi_out_vec || !ffi_out_vec->original_duckdb_vector) {
    //         return luaL_error(L, "Invalid FFIVector passed to batch string output function.");
    //     }
    //     duckdb::Vector* out_duckdb_vec = reinterpret_cast<duckdb::Vector*>(ffi_out_vec->original_duckdb_vector);
    //     auto& out_nullmask = duckdb::FlatVector::Validity(*out_duckdb_vec);
    //
    //     // 2. Loop 1 to count (Lua table is 1-indexed)
    //     for (int i = 1; i <= count; ++i) {
    //         lua_rawgeti(L, 2, i); // Pushes results_table[i] onto the stack
    //         int lua_type = lua_type(L, -1);
    //
    //         if (lua_type == LUA_TNIL) {
    //             out_nullmask.SetInvalid(i - 1); // DuckDB vector is 0-indexed
    //         } else if (lua_type == LUA_TSTRING) {
    //             size_t str_len;
    //             const char* str_data = lua_tolstring(L, -1, &str_len);
    //             // Vector::SetValue handles string heap allocation within DuckDB vector
    //             out_duckdb_vec->SetValue(i - 1, duckdb::Value(std::string(str_data, str_len)));
    //             // SetValue should also set valid, but explicitly: out_nullmask.SetValid(i-1);
    //         } else {
    //             // Should not happen if Lua code is correct
    //             out_nullmask.SetInvalid(i - 1);
    //             // Optionally, log a warning or error
    //         }
    //         lua_pop(L, 1); // Pop the table value
    //     }
    //     return 0; // Number of return values to Lua
    // }
    ```

### 4.3. Role of `LuaTranslator` (for VARCHAR output expressions)

When `LuaTranslator::TranslateExpressionToLuaRowLogic` generates the snippet for an expression that returns `VARCHAR`:
1.  It computes the Lua string value (or `nil`) and stores it in `current_row_value`.
2.  It sets `current_row_is_null` as usual.
3.  **New Step:** It appends the Lua code: `results_table[i+1] = current_row_value` (if not null) or `results_table[i+1] = nil` (if null, though `current_row_value` would already be `nil`). This step is simplified: `results_table[i+1] = current_row_value` directly, as `current_row_value` will be `nil` if the result is SQL NULL.

The translator no longer generates calls to `duckdb_ffi_add_string_to_output_vector` or `duckdb_ffi_set_string_output_null` within the per-row snippet.

### 4.4. Role of `ExpressionExecutor::ConstructFullLuaFunctionScript` (for VARCHAR output)

When the `output_logical_type` is `VARCHAR`:
1.  **Before the main loop:** It prepends `local results_table = {}` to the Lua script.
2.  **After the main loop:** It appends the call to the new batch FFI helper:
    `duckdb_ffi_add_lua_string_table_to_output_vector(output_vec_ffi, results_table, count)`
3.  **FFI CDEFs:** It must ensure the CDEF for `duckdb_ffi_add_lua_string_table_to_output_vector(lua_State* L);` (or its equivalent with arguments passed on stack) is included.

## 5. Benefits

*   **Drastically Reduced FFI Calls for String Output:** For a chunk of `N` rows, FFI calls for string output are reduced from `N` to `1`. This should significantly reduce overhead for string-heavy expressions that produce many output strings.
*   **Leverages LuaJIT's Table Optimizations:** Modern LuaJIT versions have highly optimized table implementations.

## 6. New Overheads and Challenges

*   **Lua Table Creation:** A new Lua table (`results_table`) is created for every chunk. For very small chunks, this might be a noticeable overhead.
*   **Lua Table Indexing:** `results_table[i+1] = current_row_value` happens for each row. This is an internal Lua operation and generally fast, but still an extra step per row compared to direct FFI call from row logic.
*   **C-Side Iteration of Lua Table:** The new C FFI helper function has to iterate over the Lua table using `lua_rawgeti` and `lua_tolstring`, which involves some overhead per element on the C side when retrieving from Lua.
*   **Memory for Lua Table:** The `results_table` will hold references to all generated Lua strings for the chunk. If strings are very large and numerous, this could temporarily increase memory pressure within the Lua VM before they are transferred to DuckDB. Standard Lua garbage collection applies.
*   **Complexity:** The C FFI helper function is more complex than the previous per-row helpers. Careful handling of the Lua stack and types is required.

**Trade-off Analysis:**
The expectation is that for `VARCHAR` outputs, the cost of one complex FFI call that iterates a Lua table in C, plus N Lua table assignments, will be significantly less than N separate FFI calls, each involving a C++-Lua context switch and individual string copying/management. This trade-off is likely to be more beneficial as `N` (chunk size) increases and as the cost of individual FFI calls is relatively high.
